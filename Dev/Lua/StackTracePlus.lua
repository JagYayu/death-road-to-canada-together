--[[
https://github.com/ignacio/StackTracePlus
MIT LICENSE
]]
--- @diagnostic disable
local _G=_G;local string,io,debug,coroutine=string,io,debug,coroutine;local tostring,print,require=tostring,print,require;local next,assert=next,assert;local pcall,type,pairs,ipairs=pcall,type,pairs,ipairs;local error=error;assert(debug,"debug table must be available at this point")local a=io.open;local b=string.gmatch;local c=string.sub;local d=table.concat;local e={max_tb_output_len=70}local f={[_G]="_G (global table)"}local function g(h,i)local j,k=pcall(require,h)if j then f[k]=i end end;g("string","string module")g("io","io module")g("os","os module")g("table","table module")g("math","math module")g("package","package module")g("debug","debug module")g("coroutine","coroutine module")g("bit32","bit32 module")g("bit","bit module")g("jit","jit module")if _VERSION>="Lua 5.3"then g("utf8","utf8 module")end;local l={}local m={}for n,h in ipairs({"assert","collectgarbage","dofile","error","getmetatable","ipairs","load","loadfile","next","pairs","pcall","print","rawequal","rawget","rawlen","rawset","require","select","setmetatable","tonumber","tostring","type","xpcall","gcinfo","getfenv","loadstring","module","newproxy","setfenv","unpack"})do if _G[h]then m[_G[h]]=h end end;local o={}local function p(q)local j,r=pcall(tostring,q)if j then return r else return("<failed to get printable value>: '%s'"):format(r)end end;local function s(t)assert(type(t)=="string")local u=t:match("^%s*function%s+(%w+)")if u then return u end;u=t:match("^%s*local%s+function%s+(%w+)")if u then return u end;u=t:match("^%s*local%s+(%w+)%s+=%s+function")if u then return u end;u=t:match("%s*function%s*%(")if u then return"(anonymous)"end;return"(anonymous)"end;local function v(w)if type(w.source)=="string"and w.source:sub(1,1)=="@"then local x,r=a(w.source:sub(2),"r")if not x then return end;local t;for n=1,w.linedefined do t=x:read("*l")end;if not t then return end;return s(t)else local t;local y=0;for z in b(w.source,"([^\n]+)\n-")do y=y+1;if y==w.linedefined then t=z;break end end;if not t then return end;return s(t)end end;local A={}A.new=function(B)local C={lines={}}for D,E in pairs(A)do C[D]=E end;C.dumping_same_thread=B==coroutine.running()if type(B)=="thread"then C.getinfo=function(F,G)if C.dumping_same_thread and type(F)=="number"then F=F+1 end;return debug.getinfo(B,F,G)end;C.getlocal=function(F,H)if C.dumping_same_thread then F=F+1 end;return debug.getlocal(B,F,H)end else C.getinfo=debug.getinfo;C.getlocal=debug.getlocal end;return C end;function A:add(I)self.lines[#self.lines+1]=I end;function A:add_f(J,...)self:add(J:format(...))end;function A:concat_lines()return d(self.lines)end;function A:DumpLocals(F)local K="\t "local L=1;if self.dumping_same_thread then F=F+1 end;local h,q=self.getlocal(F,L)if not h then return end;self:add("\tLocal variables:\r\n")while h do if type(q)=="number"then self:add_f("%s%s = number: %g\r\n",K,h,q)elseif type(q)=="boolean"then self:add_f("%s%s = boolean: %s\r\n",K,h,tostring(q))elseif type(q)=="string"then self:add_f("%s%s = string: %q\r\n",K,h,q)elseif type(q)=="userdata"then self:add_f("%s%s = %s\r\n",K,h,p(q))elseif type(q)=="nil"then self:add_f("%s%s = nil\r\n",K,h)elseif type(q)=="table"then if f[q]then self:add_f("%s%s = %s\r\n",K,h,f[q])elseif l[q]then self:add_f("%s%s = %s\r\n",K,h,l[q])else local M="{"for D,E in pairs(q)do M=M..p(D)..":"..p(E)if#M>e.max_tb_output_len then M=M.." (more...)"break end;if next(q,D)then M=M..", "end end;self:add_f("%s%s = %s  %s\r\n",K,h,p(q),M.."}")end elseif type(q)=="function"then local w=self.getinfo(q,"nS")local N=w.name or m[q]or o[q]if w.what=="C"then self:add_f("%s%s = C %s\r\n",K,h,N and"function: "..N or q)else local O=w.short_src;if O:sub(2,7)=="string"then O=O:sub(9)end;N=N or v(w)if N then self:add_f("%s%s = Lua function '%s' (defined at line %d of chunk %s)\r\n",K,h,N,w.linedefined,O)else self:add_f("%s%s = Lua function (defined at line %d of chunk %s)\r\n",K,h,w.linedefined,O)end end elseif type(q)=="thread"then self:add_f("%sthread %q = %s\r\n",K,h,tostring(q))end;L=L+1;h,q=self.getlocal(F,L)end end;function e.stacktrace(B,P,F)if type(B)~="thread"then B,P,F=nil,B,P end;B=B or coroutine.running()F=F or 1;local Q=A.new(B)local R;if type(P)=="table"then Q:add("an error object {\r\n")local S=true;for D,E in pairs(P)do if S then Q:add("  ")S=false else Q:add(",\r\n  ")end;Q:add(p(D))Q:add(": ")Q:add(p(E))end;Q:add("\r\n}")R=Q:concat_lines()elseif type(P)=="string"then Q:add(P)R=P end;Q:add("\r\n")Q:add([[
Stack Traceback
===============
]])local T=F;if Q.dumping_same_thread then F=F+1 end;local w=Q.getinfo(F,"nSlf")while w do if w.what=="main"then if c(w.source,1,1)=="@"then Q:add_f("(%d) main chunk of file '%s' at line %d\r\n",T,c(w.source,2),w.currentline)else Q:add_f("(%d) main chunk of %s at line %d\r\n",T,w.short_src,w.currentline)end elseif w.what=="C"then local U=o[w.func]or m[w.func]or w.name or tostring(w.func)Q:add_f("(%d) %s C function '%s'\r\n",T,w.namewhat,U)elseif w.what=="tail"then Q:add_f("(%d) tail call\r\n",T)Q:DumpLocals(F)elseif w.what=="Lua"then local O=w.short_src;local U=o[w.func]or m[w.func]or w.name;if O:sub(2,7)=="string"then O=O:sub(9)end;local V=false;if not U or U=="?"then U=v(w)V=true end;local W=w.namewhat==""and"function"or w.namewhat;if U then if w.source and w.source:sub(1,1)=="@"then Q:add_f("(%d) Lua %s '%s' at file '%s:%d'%s\r\n",T,W,U,w.source:sub(2),w.currentline,V and" (best guess)"or"")elseif w.source and w.source:sub(1,1)=="#"then Q:add_f("(%d) Lua %s '%s' at template '%s:%d'%s\r\n",T,W,U,w.source:sub(2),w.currentline,V and" (best guess)"or"")else Q:add_f("(%d) Lua %s '%s' at line %d of chunk '%s'\r\n",T,W,U,w.currentline,O)end else if w.source and w.source:sub(1,1)=="@"then Q:add_f("(%d) Lua %s at file '%s:%d'%s\r\n",T,W,w.source:sub(2),w.currentline,V and" (best guess)"or"")elseif w.source and w.source:sub(1,1)=="#"then Q:add_f("(%d) Lua %s at template '%s:%d'%s\r\n",T,W,w.source:sub(2),w.currentline,V and" (best guess)"or"")else Q:add_f("(%d) Lua %s at line %d of chunk '%s'\r\n",T,W,w.currentline,O)end end;Q:DumpLocals(F)else Q:add_f("(%d) unknown frame %s\r\n",T,w.what)end;F=F+1;T=T+1;w=Q.getinfo(F,"nSlf")end;return Q:concat_lines(),R end;function e.add_known_table(X,Y)if f[X]then error("Cannot override an already known table")end;l[X]=Y end;function e.add_known_function(Z,Y)if m[Z]then error("Cannot override an already known function")end;o[Z]=Y end;return e